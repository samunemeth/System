# --- Settings ---

set filesep ";"
set hiddenfiles ".*:desktop.ini:main.out:main.log:main.aux:main.synctex.gz:/home/samu/texmf:lost+found"
set icons "true"
set ignorecase "true"
set info "size"
set timefmt "2006-01-02 15:04:05"


# --- Mappings ---

map . set hidden!
map <enter> open
map DD delete

# These are some quick movement mappings.
map gh cd ~/
map gd cd ~/Downloads
map gn cd ~/Notes
map gm cd /run/media/
map gc cd /copyparty
map gr cd /


# --- Commands and Related Mappings ---

# Get the current files file type.
cmd type %xdg-mime query filetype "$f"

# Get the complete path of the current selection.
# Wrap it in apostrophes.
cmd path %{{
  if [[ $f = *" "* ]]; then
    fout="'$f'"
  else
    fout="$f"
  fi
  echo -n "$fout" | xclip -selection clipboard &> /dev/null
  echo "$f"
}}

# Get the size of the selected items.
cmd size %{{
  IFS=';' read -r -a files <<< "$fx"
  [ ${#files[@]} -eq 0 ] && exit 0
  du -shc -- "${files[@]}" | awk '/total/{print $1}'
}}

# A simple add menu. Inspired by nvim-tree.
# If the input ends in a slash, a folder is created. Otherwise a file is
# created. Nested paths are also cleanly handled.
map a add
cmd add %{{
  printf "New: "
  read ans
  if [[ $ans == */ ]]; then
    mkdir -p $ans
  elif [[ $ans == */* ]]; then
    mkdir -p ${ans%/*}
    touch $ans
  else
    touch $ans
  fi
}}

# Override the defult open script, as out window manager does not handle
# default applications, and that seems to be harder to do than override
# this script. It also allows for more flexibility.
cmd open &{{

  # Get the file type of the selected file.
  # We can afford this, and it is only ran after issuing an open command.
  filetype=$(xdg-mime query filetype "$f")

  # ZIP files are unzipped into a new folder.
  if [[ $filetype == "application/zip" ]] then

    todir="${f%.*}-unzip/"
    mkdir -p "$todir"
    unzip "$f" -d "$todir"
    echo "Unzipped contents."

  # PDF files are opened with Zathura. 
  # There is an extra check for LaTeX documents.
  # BUG: If there is no LaTeX support on the system you can open them.
  elif [[ $filetype == "application/pdf"* ]] then
    zathura "$f" --fork -l error

  # SVG images are not handled by Mpv.
  elif [[ $filetype == "image/svg"* ]] then
    $BROWSER --new-window "$f"

  # Basically any other multimedia is possible to open with Mpv.
  # If we can get a direct URL, use that rather than the extra abstraction.
  elif [[ $filetype =~ ^(image|video|audio) ]]; then
    if [[ $f == /copyparty* ]]; then
      furl=$(jq -nr --arg p "${f#/copyparty}" '$p | split("/") | map(@uri) | join("/")')
      burl=$(< /run/secrets/copyparty-url)
      mpv "$burl$furl"
    else
      mpv "$f"
    fi

  # E-book formats are handled by Epy.
  elif [[ $filetype =~ ^application/(epub|x-mobi) ]] then
    alacritty -e epy "$f"

  # Anything other than this just falls through to the default editor.
  else
    alacritty -e $EDITOR "$f"
  fi
}}

# Generate a URL if the file is inside the Copyparty cloned directory.
# TODO: Pull this out to a helper function somehow?
cmd url %{{
  if [[ $f == /copyparty* ]]; then
    furl=$(jq -nr --arg p "${f#/copyparty}" '$p | split("/") | map(@uri) | join("/")')
    burl=$(< /run/secrets/copyparty-url)
    echo -n "$burl$furl" | xclip -selection clipboard &> /dev/null
    echo "$burl$furl"
  else
    echo "Not available here."
  fi
}}

# Create a zip file from the selection.
# I do not remember why this is so difficult, but it works all the time.
map zz zip
cmd zip %{{
  printf "ZIP file name [NewZip.zip]: "
  read name
  name=${name:-NewZip.zip}
  IFS=';' read -ra filesarray <<< "$fx"
  filelist=""
  for absfile in "${filesarray[@]}"; do
    relfile=${absfile##"$PWD"/}
    filelist="$filelist $relfile"
  done
  zip -r "$PWD/$name" $filelist
  echo "Zipped selection."
}}

# Initiate a recursive fuzzy find with fzf. There is some configuration
# included for asthetic reasons. The selected item is highlighted after
# the window disappears. The only difference between the two are the flags
# that are passed to fd. 
map / fzf-normal
cmd fzf-normal ${{
  res="$(fd | fzf --smart-case --style=minimal \
    --color="pointer:magenta,hl:magenta,hl+:magenta,separator:grey,info:grey:bold,prompt:white" \
    --info=right --pointer="█" --separator="━")"
  if [ -n "$res" ]; then
    if [ -d "$res" ]; then
      res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
      lf -remote "send $id cd \"$res\""
    else
      dir=$(dirname -- "$res")
      dir="$(printf '%s' "$dir" | sed 's/\\/\\\\/g;s/"/\\"/g')"
      lf -remote "send $id cd \"$dir\""
      file=$(basename -- "$res")
      file="$(printf '%s' "$file" | sed 's/\\/\\\\/g;s/"/\\"/g')"
      lf -remote "send $id select \"$file\""
    fi
  fi
}}
map ? fzf-hidden
cmd fzf-hidden ${{
  res="$(fd -I -H | fzf --smart-case --style=minimal \
    --color="pointer:magenta,hl:magenta,hl+:magenta,separator:grey,info:grey:bold,prompt:white" \
    --info=right --pointer="█" --separator="━")"
  if [ -n "$res" ]; then
    if [ -d "$res" ]; then
      res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
      lf -remote "send $id cd \"$res\""
    else
      dir=$(dirname -- "$res")
      dir="$(printf '%s' "$dir" | sed 's/\\/\\\\/g;s/"/\\"/g')"
      lf -remote "send $id Cd \"$dir\""
      file=$(basename -- "$res")
      file="$(printf '%s' "$file" | sed 's/\\/\\\\/g;s/"/\\"/g')"
      lf -remote "send $id select \"$file\""
    fi
  fi
}}

